// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: events.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const handleLimitBuyOrderCancelled = `-- name: HandleLimitBuyOrderCancelled :exec
WITH cancelled_order AS (
    UPDATE orders
    SET status = 'CANCELLED',
        cancelled_at = NOW(),
        updated_at = NOW()
    WHERE orders.id = $1
        AND status IN ('PENDING', 'PARTIAL')
    RETURNING id,
        trader_id,
        remaining_quantity,
        limit_price_cents
),
return_trader_cash AS (
    UPDATE traders
    SET cash_balance_cents = traders.cash_balance_cents + (co.remaining_quantity * co.limit_price_cents),
        cash_hold_cents = traders.cash_hold_cents - (co.remaining_quantity * co.limit_price_cents),
        updated_at = NOW()
    FROM cancelled_order co
    WHERE traders.id = co.trader_id
)
SELECT 1
`

// Release cash hold for limit buy
func (q *Queries) HandleLimitBuyOrderCancelled(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, handleLimitBuyOrderCancelled, id)
	return err
}

const handleLimitBuyOrderPlaced = `-- name: HandleLimitBuyOrderPlaced :exec
WITH inserted_order AS (
    INSERT INTO orders (
            id,
            trader_id,
            stock_ticker,
            order_type,
            side,
            quantity,
            remaining_quantity,
            limit_price_cents,
            status
        )
    VALUES (
            $1,
            $2,
            $3,
            'LIMIT',
            'BUY',
            $4,
            $4,
            $5,
            'PENDING'
        )
    RETURNING id,
        trader_id,
        quantity,
        limit_price_cents
),
lock_trader_cash AS (
    UPDATE traders
    SET cash_balance_cents = traders.cash_balance_cents - (io.quantity * io.limit_price_cents),
        cash_hold_cents = traders.cash_hold_cents + (io.quantity * io.limit_price_cents),
        updated_at = NOW()
    FROM inserted_order io
    WHERE traders.id = io.trader_id
)
SELECT 1
`

type HandleLimitBuyOrderPlacedParams struct {
	ID              pgtype.UUID `json:"id"`
	TraderID        int64       `json:"trader_id"`
	StockTicker     string      `json:"stock_ticker"`
	Quantity        int64       `json:"quantity"`
	LimitPriceCents pgtype.Int8 `json:"limit_price_cents"`
}

// Lock cash at limit price
func (q *Queries) HandleLimitBuyOrderPlaced(ctx context.Context, arg HandleLimitBuyOrderPlacedParams) error {
	_, err := q.db.Exec(ctx, handleLimitBuyOrderPlaced,
		arg.ID,
		arg.TraderID,
		arg.StockTicker,
		arg.Quantity,
		arg.LimitPriceCents,
	)
	return err
}

const handleLimitBuyTradeExecuted = `-- name: HandleLimitBuyTradeExecuted :exec
WITH trade_info AS (
    INSERT INTO trades (
            stock_ticker,
            buyer_order_id,
            seller_order_id,
            buyer_trader_id,
            seller_trader_id,
            quantity,
            price_cents,
            total_value_cents
        )
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    RETURNING buyer_order_id,
        seller_order_id,
        buyer_trader_id,
        seller_trader_id,
        stock_ticker,
        quantity,
        price_cents,
        total_value_cents
),
buyer_order AS (
    SELECT o.limit_price_cents
    FROM orders o
        INNER JOIN trade_info ti ON o.id = ti.buyer_order_id
),
release_buyer_cash_hold AS (
    UPDATE traders
    SET cash_hold_cents = traders.cash_hold_cents - (ti.quantity * bo.limit_price_cents),
        cash_balance_cents = traders.cash_balance_cents + (
            (ti.quantity * bo.limit_price_cents) - ti.total_value_cents
        ),
        updated_at = NOW()
    FROM trade_info ti
        CROSS JOIN buyer_order bo
    WHERE traders.id = ti.buyer_trader_id
),
buyer_add_position AS (
    INSERT INTO positions (
            trader_id,
            stock_ticker,
            quantity,
            total_cost_cents
        )
    SELECT ti.buyer_trader_id,
        ti.stock_ticker,
        ti.quantity,
        ti.total_value_cents
    FROM trade_info ti ON CONFLICT (trader_id, stock_ticker) DO
    UPDATE
    SET quantity = positions.quantity + EXCLUDED.quantity,
        total_cost_cents = positions.total_cost_cents + EXCLUDED.total_cost_cents,
        updated_at = NOW()
),
seller_release_hold AS (
    UPDATE positions
    SET quantity_hold = positions.quantity_hold - ti.quantity,
        total_cost_cents = GREATEST(
            0,
            positions.total_cost_cents - (
                (positions.total_cost_cents * ti.quantity) / NULLIF(positions.quantity, 0)
            )
        ),
        updated_at = NOW()
    FROM trade_info ti
    WHERE positions.trader_id = ti.seller_trader_id
        AND positions.stock_ticker = ti.stock_ticker
),
seller_add_cash AS (
    UPDATE traders
    SET cash_balance_cents = traders.cash_balance_cents + ti.total_value_cents,
        updated_at = NOW()
    FROM trade_info ti
    WHERE traders.id = ti.seller_trader_id
),
update_stock_price AS (
    UPDATE stocks
    SET current_price_cents = ti.price_cents,
        updated_at = NOW()
    FROM trade_info ti
    WHERE stocks.ticker = ti.stock_ticker
),
update_buyer_portfolio AS (
    SELECT update_trader_portfolio_value(ti.buyer_trader_id)
    FROM trade_info ti
),
update_seller_portfolio AS (
    SELECT update_trader_portfolio_value(ti.seller_trader_id)
    FROM trade_info ti
)
SELECT 1
`

type HandleLimitBuyTradeExecutedParams struct {
	StockTicker     string      `json:"stock_ticker"`
	BuyerOrderID    pgtype.UUID `json:"buyer_order_id"`
	SellerOrderID   pgtype.UUID `json:"seller_order_id"`
	BuyerTraderID   int64       `json:"buyer_trader_id"`
	SellerTraderID  int64       `json:"seller_trader_id"`
	Quantity        int64       `json:"quantity"`
	PriceCents      int64       `json:"price_cents"`
	TotalValueCents int64       `json:"total_value_cents"`
}

// Get buyer's limit price for hold release calculation
// Release buyer's cash hold at limit price, refund price improvement
// Add shares to buyer's position
// Release seller's share hold
// Add cash to seller
// Update stock price
// Update buyer's portfolio value
// Update seller's portfolio value
func (q *Queries) HandleLimitBuyTradeExecuted(ctx context.Context, arg HandleLimitBuyTradeExecutedParams) error {
	_, err := q.db.Exec(ctx, handleLimitBuyTradeExecuted,
		arg.StockTicker,
		arg.BuyerOrderID,
		arg.SellerOrderID,
		arg.BuyerTraderID,
		arg.SellerTraderID,
		arg.Quantity,
		arg.PriceCents,
		arg.TotalValueCents,
	)
	return err
}

const handleMarketBuyOrderCancelled = `-- name: HandleMarketBuyOrderCancelled :exec
UPDATE orders
SET status = 'CANCELLED',
    cancelled_at = NOW(),
    updated_at = NOW()
WHERE orders.id = $1
    AND status IN ('PENDING', 'PARTIAL')
`

func (q *Queries) HandleMarketBuyOrderCancelled(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, handleMarketBuyOrderCancelled, id)
	return err
}

const handleMarketBuyOrderPlaced = `-- name: HandleMarketBuyOrderPlaced :exec
INSERT INTO orders (
        id,
        trader_id,
        stock_ticker,
        order_type,
        side,
        quantity,
        remaining_quantity,
        limit_price_cents,
        status
    )
VALUES (
        $1,
        $2,
        $3,
        'MARKET',
        'BUY',
        $4,
        $4,
        NULL,
        'PENDING'
    )
`

type HandleMarketBuyOrderPlacedParams struct {
	ID          pgtype.UUID `json:"id"`
	TraderID    int64       `json:"trader_id"`
	StockTicker string      `json:"stock_ticker"`
	Quantity    int64       `json:"quantity"`
}

func (q *Queries) HandleMarketBuyOrderPlaced(ctx context.Context, arg HandleMarketBuyOrderPlacedParams) error {
	_, err := q.db.Exec(ctx, handleMarketBuyOrderPlaced,
		arg.ID,
		arg.TraderID,
		arg.StockTicker,
		arg.Quantity,
	)
	return err
}

const handleMarketBuyTradeExecuted = `-- name: HandleMarketBuyTradeExecuted :exec
WITH trade_info AS (
    INSERT INTO trades (
            stock_ticker,
            buyer_order_id,
            seller_order_id,
            buyer_trader_id,
            seller_trader_id,
            quantity,
            price_cents,
            total_value_cents
        )
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    RETURNING buyer_order_id,
        seller_order_id,
        buyer_trader_id,
        seller_trader_id,
        stock_ticker,
        quantity,
        price_cents,
        total_value_cents
),
deduct_buyer_cash AS (
    UPDATE traders
    SET cash_balance_cents = traders.cash_balance_cents - ti.total_value_cents,
        updated_at = NOW()
    FROM trade_info ti
    WHERE traders.id = ti.buyer_trader_id
),
buyer_add_position AS (
    INSERT INTO positions (
            trader_id,
            stock_ticker,
            quantity,
            total_cost_cents
        )
    SELECT ti.buyer_trader_id,
        ti.stock_ticker,
        ti.quantity,
        ti.total_value_cents
    FROM trade_info ti ON CONFLICT (trader_id, stock_ticker) DO
    UPDATE
    SET quantity = positions.quantity + EXCLUDED.quantity,
        total_cost_cents = positions.total_cost_cents + EXCLUDED.total_cost_cents,
        updated_at = NOW()
),
seller_release_hold AS (
    UPDATE positions
    SET quantity_hold = positions.quantity_hold - ti.quantity,
        total_cost_cents = GREATEST(
            0,
            positions.total_cost_cents - (
                (positions.total_cost_cents * ti.quantity) / NULLIF(positions.quantity, 0)
            )
        ),
        updated_at = NOW()
    FROM trade_info ti
    WHERE positions.trader_id = ti.seller_trader_id
        AND positions.stock_ticker = ti.stock_ticker
),
seller_add_cash AS (
    UPDATE traders
    SET cash_balance_cents = traders.cash_balance_cents + ti.total_value_cents,
        updated_at = NOW()
    FROM trade_info ti
    WHERE traders.id = ti.seller_trader_id
),
update_stock_price AS (
    UPDATE stocks
    SET current_price_cents = ti.price_cents,
        updated_at = NOW()
    FROM trade_info ti
    WHERE stocks.ticker = ti.stock_ticker
),
update_buyer_portfolio AS (
    SELECT update_trader_portfolio_value(ti.buyer_trader_id)
    FROM trade_info ti
),
update_seller_portfolio AS (
    SELECT update_trader_portfolio_value(ti.seller_trader_id)
    FROM trade_info ti
)
SELECT 1
`

type HandleMarketBuyTradeExecutedParams struct {
	StockTicker     string      `json:"stock_ticker"`
	BuyerOrderID    pgtype.UUID `json:"buyer_order_id"`
	SellerOrderID   pgtype.UUID `json:"seller_order_id"`
	BuyerTraderID   int64       `json:"buyer_trader_id"`
	SellerTraderID  int64       `json:"seller_trader_id"`
	Quantity        int64       `json:"quantity"`
	PriceCents      int64       `json:"price_cents"`
	TotalValueCents int64       `json:"total_value_cents"`
}

// Deduct cash directly from buyer's balance (no hold exists)
// Add shares to buyer's position
// Release seller's share hold
// Add cash to seller
// Update stock price
// Update buyer's portfolio value
// Update seller's portfolio value
func (q *Queries) HandleMarketBuyTradeExecuted(ctx context.Context, arg HandleMarketBuyTradeExecutedParams) error {
	_, err := q.db.Exec(ctx, handleMarketBuyTradeExecuted,
		arg.StockTicker,
		arg.BuyerOrderID,
		arg.SellerOrderID,
		arg.BuyerTraderID,
		arg.SellerTraderID,
		arg.Quantity,
		arg.PriceCents,
		arg.TotalValueCents,
	)
	return err
}

const handleOrderFilled = `-- name: HandleOrderFilled :exec
UPDATE orders
SET status = 'FILLED',
    filled_quantity = orders.quantity,
    remaining_quantity = 0,
    filled_at = NOW(),
    updated_at = NOW()
WHERE orders.id = $1
`

func (q *Queries) HandleOrderFilled(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, handleOrderFilled, id)
	return err
}

const handleOrderPartiallyFilled = `-- name: HandleOrderPartiallyFilled :exec
UPDATE orders
SET filled_quantity = orders.filled_quantity + $2,
    remaining_quantity = orders.remaining_quantity - $2,
    status = 'PARTIAL',
    updated_at = NOW()
WHERE orders.id = $1
`

type HandleOrderPartiallyFilledParams struct {
	ID             pgtype.UUID `json:"id"`
	FilledQuantity pgtype.Int8 `json:"filled_quantity"`
}

func (q *Queries) HandleOrderPartiallyFilled(ctx context.Context, arg HandleOrderPartiallyFilledParams) error {
	_, err := q.db.Exec(ctx, handleOrderPartiallyFilled, arg.ID, arg.FilledQuantity)
	return err
}

const handleOrderRejected = `-- name: HandleOrderRejected :exec
INSERT INTO orders (
        id,
        trader_id,
        status
    )
VALUES ($1, $2, 'REJECTED')
`

type HandleOrderRejectedParams struct {
	ID       pgtype.UUID `json:"id"`
	TraderID int64       `json:"trader_id"`
}

func (q *Queries) HandleOrderRejected(ctx context.Context, arg HandleOrderRejectedParams) error {
	_, err := q.db.Exec(ctx, handleOrderRejected, arg.ID, arg.TraderID)
	return err
}

const handleSellOrderCancelled = `-- name: HandleSellOrderCancelled :exec
WITH cancelled_order AS (
    UPDATE orders
    SET status = 'CANCELLED',
        cancelled_at = NOW(),
        updated_at = NOW()
    WHERE orders.id = $1
        AND status IN ('PENDING', 'PARTIAL')
    RETURNING id,
        trader_id,
        stock_ticker,
        remaining_quantity
),
return_trader_shares AS (
    UPDATE positions
    SET quantity = positions.quantity + co.remaining_quantity,
        quantity_hold = positions.quantity_hold - co.remaining_quantity,
        updated_at = NOW()
    FROM cancelled_order co
    WHERE positions.trader_id = co.trader_id
        AND positions.stock_ticker = co.stock_ticker
)
SELECT 1
`

// Release share hold for sell orders
func (q *Queries) HandleSellOrderCancelled(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, handleSellOrderCancelled, id)
	return err
}

const handleSellOrderPlaced = `-- name: HandleSellOrderPlaced :exec
WITH inserted_order AS (
    INSERT INTO orders (
            id,
            trader_id,
            stock_ticker,
            order_type,
            side,
            quantity,
            remaining_quantity,
            limit_price_cents,
            status
        )
    VALUES ($1, $2, $3, $4, 'SELL', $5, $5, $6, 'PENDING')
    RETURNING id,
        trader_id,
        stock_ticker,
        quantity
),
lock_trader_shares AS (
    UPDATE positions
    SET quantity = positions.quantity - io.quantity,
        quantity_hold = positions.quantity_hold + io.quantity,
        updated_at = NOW()
    FROM inserted_order io
    WHERE positions.trader_id = io.trader_id
        AND positions.stock_ticker = io.stock_ticker
)
SELECT 1
`

type HandleSellOrderPlacedParams struct {
	ID              pgtype.UUID `json:"id"`
	TraderID        int64       `json:"trader_id"`
	StockTicker     string      `json:"stock_ticker"`
	OrderType       string      `json:"order_type"`
	Quantity        int64       `json:"quantity"`
	LimitPriceCents pgtype.Int8 `json:"limit_price_cents"`
}

// Lock shares for sell
func (q *Queries) HandleSellOrderPlaced(ctx context.Context, arg HandleSellOrderPlacedParams) error {
	_, err := q.db.Exec(ctx, handleSellOrderPlaced,
		arg.ID,
		arg.TraderID,
		arg.StockTicker,
		arg.OrderType,
		arg.Quantity,
		arg.LimitPriceCents,
	)
	return err
}
