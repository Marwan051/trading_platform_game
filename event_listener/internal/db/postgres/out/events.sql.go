// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: events.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const handleOrderCancelled = `-- name: HandleOrderCancelled :exec
WITH cancelled_order AS (
    UPDATE orders
    SET status = 'CANCELLED',
        cancelled_at = NOW(),
        updated_at = NOW()
    WHERE orders.id = $1
        AND status IN ('PENDING', 'PARTIAL')
    RETURNING id,
        user_id,
        bot_id,
        order_type,
        side,
        remaining_quantity,
        limit_price_cents,
        stock_ticker
),
return_user_cash AS (
    UPDATE user_profile
    SET cash_balance_cents = user_profile.cash_balance_cents + (co.remaining_quantity * co.limit_price_cents),
        cash_hold_cents = user_profile.cash_hold_cents - (co.remaining_quantity * co.limit_price_cents),
        updated_at = NOW()
    FROM cancelled_order co
    WHERE user_profile.user_id = co.user_id
        AND co.side = 'BUY'
        AND co.order_type = 'LIMIT'
        AND co.user_id IS NOT NULL
),
return_bot_cash AS (
    UPDATE bots
    SET cash_balance_cents = bots.cash_balance_cents + (co.remaining_quantity * co.limit_price_cents),
        cash_hold_cents = bots.cash_hold_cents - (co.remaining_quantity * co.limit_price_cents),
        updated_at = NOW()
    FROM cancelled_order co
    WHERE bots.id = co.bot_id
        AND co.side = 'BUY'
        AND co.order_type = 'LIMIT'
        AND co.bot_id IS NOT NULL
),
return_user_shares AS (
    UPDATE positions
    SET quantity = positions.quantity + co.remaining_quantity,
        quantity_hold = positions.quantity_hold - co.remaining_quantity,
        updated_at = NOW()
    FROM cancelled_order co
    WHERE positions.user_id = co.user_id
        AND positions.stock_ticker = co.stock_ticker
        AND co.side = 'SELL'
        AND co.user_id IS NOT NULL
),
return_bot_shares AS (
    UPDATE positions
    SET quantity = positions.quantity + co.remaining_quantity,
        quantity_hold = positions.quantity_hold - co.remaining_quantity,
        updated_at = NOW()
    FROM cancelled_order co
    WHERE positions.bot_id = co.bot_id
        AND positions.stock_ticker = co.stock_ticker
        AND co.side = 'SELL'
        AND co.bot_id IS NOT NULL
)
SELECT 1
`

// For LIMIT BUY orders: release cash hold
// For ALL SELL orders: release share hold
func (q *Queries) HandleOrderCancelled(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, handleOrderCancelled, id)
	return err
}

const handleOrderFilled = `-- name: HandleOrderFilled :exec
UPDATE orders
SET status = 'FILLED',
    filled_quantity = orders.quantity,
    remaining_quantity = 0,
    filled_at = NOW(),
    updated_at = NOW()
WHERE orders.id = $1
`

func (q *Queries) HandleOrderFilled(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, handleOrderFilled, id)
	return err
}

const handleOrderPartiallyFilled = `-- name: HandleOrderPartiallyFilled :exec
UPDATE orders
SET filled_quantity = orders.filled_quantity + $2,
    remaining_quantity = orders.remaining_quantity - $2,
    status = 'PARTIAL',
    updated_at = NOW()
WHERE orders.id = $1
`

type HandleOrderPartiallyFilledParams struct {
	ID             pgtype.UUID `json:"id"`
	FilledQuantity pgtype.Int8 `json:"filled_quantity"`
}

func (q *Queries) HandleOrderPartiallyFilled(ctx context.Context, arg HandleOrderPartiallyFilledParams) error {
	_, err := q.db.Exec(ctx, handleOrderPartiallyFilled, arg.ID, arg.FilledQuantity)
	return err
}

const handleOrderPlaced = `-- name: HandleOrderPlaced :exec
WITH inserted_order AS (
    INSERT INTO orders (
            id,
            user_id,
            bot_id,
            stock_ticker,
            order_type,
            side,
            quantity,
            remaining_quantity,
            limit_price_cents,
            status
        )
    VALUES ($1, $2, $3, $4, $5, $6, $7, $7, $8, 'PENDING')
    RETURNING id,
        user_id,
        bot_id,
        order_type,
        side,
        quantity,
        limit_price_cents,
        stock_ticker
),
lock_user_cash AS (
    UPDATE user_profile
    SET cash_balance_cents = user_profile.cash_balance_cents - (io.quantity * io.limit_price_cents),
        cash_hold_cents = user_profile.cash_hold_cents + (io.quantity * io.limit_price_cents),
        updated_at = NOW()
    FROM inserted_order io
    WHERE user_profile.user_id = io.user_id
        AND io.side = 'BUY'
        AND io.order_type = 'LIMIT'
        AND io.user_id IS NOT NULL
),
lock_bot_cash AS (
    UPDATE bots
    SET cash_balance_cents = bots.cash_balance_cents - (io.quantity * io.limit_price_cents),
        cash_hold_cents = bots.cash_hold_cents + (io.quantity * io.limit_price_cents),
        updated_at = NOW()
    FROM inserted_order io
    WHERE bots.id = io.bot_id
        AND io.side = 'BUY'
        AND io.order_type = 'LIMIT'
        AND io.bot_id IS NOT NULL
),
lock_user_shares AS (
    UPDATE positions
    SET quantity = positions.quantity - io.quantity,
        quantity_hold = positions.quantity_hold + io.quantity,
        updated_at = NOW()
    FROM inserted_order io
    WHERE positions.user_id = io.user_id
        AND positions.stock_ticker = io.stock_ticker
        AND io.side = 'SELL'
        AND io.user_id IS NOT NULL
),
lock_bot_shares AS (
    UPDATE positions
    SET quantity = positions.quantity - io.quantity,
        quantity_hold = positions.quantity_hold + io.quantity,
        updated_at = NOW()
    FROM inserted_order io
    WHERE positions.bot_id = io.bot_id
        AND positions.stock_ticker = io.stock_ticker
        AND io.side = 'SELL'
        AND io.bot_id IS NOT NULL
)
SELECT 1
`

type HandleOrderPlacedParams struct {
	ID              pgtype.UUID `json:"id"`
	UserID          pgtype.Text `json:"user_id"`
	BotID           pgtype.Int8 `json:"bot_id"`
	StockTicker     string      `json:"stock_ticker"`
	OrderType       string      `json:"order_type"`
	Side            string      `json:"side"`
	Quantity        int64       `json:"quantity"`
	LimitPriceCents pgtype.Int8 `json:"limit_price_cents"`
}

// For LIMIT BUY orders: lock cash (market buys have no hold, deducted on trade)
// For ALL SELL orders: lock shares (both market and limit)
func (q *Queries) HandleOrderPlaced(ctx context.Context, arg HandleOrderPlacedParams) error {
	_, err := q.db.Exec(ctx, handleOrderPlaced,
		arg.ID,
		arg.UserID,
		arg.BotID,
		arg.StockTicker,
		arg.OrderType,
		arg.Side,
		arg.Quantity,
		arg.LimitPriceCents,
	)
	return err
}

const handleOrderRejected = `-- name: HandleOrderRejected :exec
INSERT INTO orders (
        id,
        user_id,
        bot_id,
        status
    )
VALUES ($1, $2, $3, 'REJECTED')
`

type HandleOrderRejectedParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.Text `json:"user_id"`
	BotID  pgtype.Int8 `json:"bot_id"`
}

func (q *Queries) HandleOrderRejected(ctx context.Context, arg HandleOrderRejectedParams) error {
	_, err := q.db.Exec(ctx, handleOrderRejected, arg.ID, arg.UserID, arg.BotID)
	return err
}

const handleTradeExecuted = `-- name: HandleTradeExecuted :exec
WITH trade_info AS (
    INSERT INTO trades (
            id,
            stock_ticker,
            buyer_order_id,
            seller_order_id,
            buyer_user_id,
            buyer_bot_id,
            seller_user_id,
            seller_bot_id,
            quantity,
            price_cents,
            total_value_cents
        )
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
    RETURNING buyer_order_id,
        seller_order_id,
        buyer_user_id,
        buyer_bot_id,
        seller_user_id,
        seller_bot_id,
        stock_ticker,
        quantity,
        price_cents,
        total_value_cents
),
buyer_order AS (
    SELECT o.order_type,
        o.limit_price_cents
    FROM orders o
        INNER JOIN trade_info ti ON o.id = ti.buyer_order_id
),
release_buyer_user_limit_hold AS (
    UPDATE user_profile
    SET cash_hold_cents = user_profile.cash_hold_cents - (ti.quantity * bo.limit_price_cents),
        cash_balance_cents = user_profile.cash_balance_cents + (
            (ti.quantity * bo.limit_price_cents) - ti.total_value_cents
        ),
        updated_at = NOW()
    FROM trade_info ti
        CROSS JOIN buyer_order bo
    WHERE user_profile.user_id = ti.buyer_user_id
        AND ti.buyer_user_id IS NOT NULL
        AND bo.order_type = 'LIMIT'
),
release_buyer_bot_limit_hold AS (
    UPDATE bots
    SET cash_hold_cents = bots.cash_hold_cents - (ti.quantity * bo.limit_price_cents),
        cash_balance_cents = bots.cash_balance_cents + (
            (ti.quantity * bo.limit_price_cents) - ti.total_value_cents
        ),
        updated_at = NOW()
    FROM trade_info ti
        CROSS JOIN buyer_order bo
    WHERE bots.id = ti.buyer_bot_id
        AND ti.buyer_bot_id IS NOT NULL
        AND bo.order_type = 'LIMIT'
),
deduct_buyer_user_market_cash AS (
    UPDATE user_profile
    SET cash_balance_cents = user_profile.cash_balance_cents - ti.total_value_cents,
        updated_at = NOW()
    FROM trade_info ti
        CROSS JOIN buyer_order bo
    WHERE user_profile.user_id = ti.buyer_user_id
        AND ti.buyer_user_id IS NOT NULL
        AND bo.order_type = 'MARKET'
),
deduct_buyer_bot_market_cash AS (
    UPDATE bots
    SET cash_balance_cents = bots.cash_balance_cents - ti.total_value_cents,
        updated_at = NOW()
    FROM trade_info ti
        CROSS JOIN buyer_order bo
    WHERE bots.id = ti.buyer_bot_id
        AND ti.buyer_bot_id IS NOT NULL
        AND bo.order_type = 'MARKET'
),
buyer_user_add_position AS (
    INSERT INTO positions (
            user_id,
            stock_ticker,
            quantity,
            average_cost_cents,
            total_cost_cents
        )
    SELECT ti.buyer_user_id,
        ti.stock_ticker,
        ti.quantity,
        ti.price_cents,
        ti.total_value_cents
    FROM trade_info ti
    WHERE ti.buyer_user_id IS NOT NULL ON CONFLICT (user_id, stock_ticker)
    WHERE user_id IS NOT NULL DO
    UPDATE
    SET quantity = positions.quantity + EXCLUDED.quantity,
        total_cost_cents = positions.total_cost_cents + EXCLUDED.total_cost_cents,
        average_cost_cents = (
            positions.total_cost_cents + EXCLUDED.total_cost_cents
        ) / (positions.quantity + EXCLUDED.quantity),
        updated_at = NOW()
),
buyer_bot_add_position AS (
    INSERT INTO positions (
            bot_id,
            stock_ticker,
            quantity,
            average_cost_cents,
            total_cost_cents
        )
    SELECT ti.buyer_bot_id,
        ti.stock_ticker,
        ti.quantity,
        ti.price_cents,
        ti.total_value_cents
    FROM trade_info ti
    WHERE ti.buyer_bot_id IS NOT NULL ON CONFLICT (bot_id, stock_ticker)
    WHERE bot_id IS NOT NULL DO
    UPDATE
    SET quantity = positions.quantity + EXCLUDED.quantity,
        total_cost_cents = positions.total_cost_cents + EXCLUDED.total_cost_cents,
        average_cost_cents = (
            positions.total_cost_cents + EXCLUDED.total_cost_cents
        ) / (positions.quantity + EXCLUDED.quantity),
        updated_at = NOW()
),
seller_user_release_hold AS (
    UPDATE positions
    SET quantity_hold = positions.quantity_hold - ti.quantity,
        total_cost_cents = GREATEST(
            0,
            positions.total_cost_cents - (ti.quantity * positions.average_cost_cents)
        ),
        updated_at = NOW()
    FROM trade_info ti
    WHERE positions.user_id = ti.seller_user_id
        AND positions.stock_ticker = ti.stock_ticker
        AND ti.seller_user_id IS NOT NULL
),
seller_bot_release_hold AS (
    UPDATE positions
    SET quantity_hold = positions.quantity_hold - ti.quantity,
        total_cost_cents = GREATEST(
            0,
            positions.total_cost_cents - (ti.quantity * positions.average_cost_cents)
        ),
        updated_at = NOW()
    FROM trade_info ti
    WHERE positions.bot_id = ti.seller_bot_id
        AND positions.stock_ticker = ti.stock_ticker
        AND ti.seller_bot_id IS NOT NULL
),
seller_user_add_cash AS (
    UPDATE user_profile
    SET cash_balance_cents = user_profile.cash_balance_cents + ti.total_value_cents,
        updated_at = NOW()
    FROM trade_info ti
    WHERE user_profile.user_id = ti.seller_user_id
        AND ti.seller_user_id IS NOT NULL
),
seller_bot_add_cash AS (
    UPDATE bots
    SET cash_balance_cents = bots.cash_balance_cents + ti.total_value_cents,
        updated_at = NOW()
    FROM trade_info ti
    WHERE bots.id = ti.seller_bot_id
        AND ti.seller_bot_id IS NOT NULL
),
update_stock_price AS (
    UPDATE stocks
    SET current_price_cents = ti.price_cents,
        updated_at = NOW()
    FROM trade_info ti
    WHERE stocks.ticker = ti.stock_ticker
)
SELECT 1
`

type HandleTradeExecutedParams struct {
	ID              pgtype.UUID `json:"id"`
	StockTicker     string      `json:"stock_ticker"`
	BuyerOrderID    pgtype.UUID `json:"buyer_order_id"`
	SellerOrderID   pgtype.UUID `json:"seller_order_id"`
	BuyerUserID     pgtype.Text `json:"buyer_user_id"`
	BuyerBotID      pgtype.Int8 `json:"buyer_bot_id"`
	SellerUserID    pgtype.Text `json:"seller_user_id"`
	SellerBotID     pgtype.Int8 `json:"seller_bot_id"`
	Quantity        int64       `json:"quantity"`
	PriceCents      int64       `json:"price_cents"`
	TotalValueCents int64       `json:"total_value_cents"`
}

// Look up buyer order type to know if cash is in hold or needs direct deduction
// LIMIT BUY: release hold at limit price, refund price improvement to balance
// MARKET BUY: deduct cash directly from balance (no hold exists)
// BUYER: Add shares to position
// SELLER: Release quantity_hold (shares were already in hold, now they're gone)
// SELLER: Add cash from sale
// Update stock price to reflect the latest trade price
func (q *Queries) HandleTradeExecuted(ctx context.Context, arg HandleTradeExecutedParams) error {
	_, err := q.db.Exec(ctx, handleTradeExecuted,
		arg.ID,
		arg.StockTicker,
		arg.BuyerOrderID,
		arg.SellerOrderID,
		arg.BuyerUserID,
		arg.BuyerBotID,
		arg.SellerUserID,
		arg.SellerBotID,
		arg.Quantity,
		arg.PriceCents,
		arg.TotalValueCents,
	)
	return err
}
